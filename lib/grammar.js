/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#aa20f58298ad0ce94f9a59966739d16975cb2853
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { interpolateArray as _interpolateArray, interpolateArrayChildren as _interpolateArrayChildren, interpolateString as _interpolateString } from "@bablr/agast-helpers/template";
import * as _l from "@bablr/agast-vm-helpers/languages";
import * as _t from "@bablr/agast-helpers/shorthand";
let _initProto, _BlockCommentDecs, _LineCommentDecs, _AnyDecs, _PunctuatorDecs;
import { Node, CoveredBy, InjectFrom } from '@bablr/helpers/decorators';
import * as Shared from '@bablr/helpers/productions';
import * as Space from '@bablr/language-en-blank-space';
export const canonicalURL = 'https://bablr.org/languages/core/en/c-comments';
export const dependencies = {
  Space
};
export const grammar = class CCommentsGrammar {
  static {
    [_initProto] = _applyDecs(this, [[_BlockCommentDecs, 2, "BlockComment"], [_LineCommentDecs, 2, "LineComment"], [Node, 2, "Content"], [_AnyDecs, 2, "Any"], [_PunctuatorDecs, 2, "Punctuator"]], []).e;
  }
  constructor() {
    _initProto(this);
  }
  *[(_BlockCommentDecs = [CoveredBy('Comment'), Node], _LineCommentDecs = [CoveredBy('Comment'), Node], _AnyDecs = InjectFrom(Shared), _PunctuatorDecs = [Node, InjectFrom(Shared)], "Trivia")]() {
    while (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`triviaToken`, _t.ref`tokenToken`], {
              triviaToken: _t.s_i_node(_l.CSTML, "Punctuator", "#"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            language: _t.s_node(_l.Spamex, "Identifier", "Space"),
            namespaceSeparatorToken: _t.s_i_node(_l.Spamex, "Punctuator", ":"),
            type: _t.s_node(_l.Spamex, "Identifier", "Space"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}) || (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Comment"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})));
  }
  *Comment() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [9, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n    ")], {}, {})), _t.ref`closeToken`]]], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "BlockComment"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("/*")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "LineComment"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("//")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *BlockComment() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [14, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr()], [_t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("/*")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("*/")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {}), _t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancedSpan"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Comment:Block")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Content"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("content")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("*/")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *LineComment() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("//")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("start")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [10, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Content"),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "span"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Comment:Line")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("content")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Content({
    state: {
      span
    }
  }) {
    if (span === 'Comment:Block') {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                element: _t.node(_l.Regex, "CapturingGroup", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
                  openToken: _t.s_i_node(_l.Regex, "Punctuator", "("),
                  alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\*")], {}, {
                      cooked: "*"
                    }))], {}, {}), _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`negateToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`closeToken`], {
                      openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                      negateToken: _t.s_i_node(_l.Regex, "Keyword", "^"),
                      elements: [_t.node(_l.Regex, "Character", [_t.lit("/")], {}, {})],
                      closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                    }, {
                      negate: true
                    })]
                  }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "AnyCharacterSet", [_t.ref`sigilToken`], {
                      sigilToken: _t.s_i_node(_l.Regex, "Keyword", ".")
                    }, {})]
                  }, {})],
                  separators: [_t.s_i_node(_l.Regex, "Punctuator", "|")],
                  closeToken: _t.s_i_node(_l.Regex, "Punctuator", ")")
                }, {}),
                value: _t.s_i_node(_l.Regex, "Keyword", "*")
              }, {
                min: 0,
                max: Infinity,
                greedy: true
              })]
            }, {})],
            closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else if (span === 'Comment:Line') {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                element: _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`negateToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  negateToken: _t.s_i_node(_l.Regex, "Keyword", "^"),
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\n")], {}, {
                    cooked: "\n"
                  }))], {}, {})],
                  closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: true
                }),
                value: _t.s_i_node(_l.Regex, "Keyword", "*")
              }, {
                min: 0,
                max: Infinity,
                greedy: true
              })]
            }, {})],
            closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      throw new Error();
    }
  }
  *Any() {}
  *Punctuator() {}
};